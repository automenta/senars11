import {ConfigManager} from '../config/ConfigManager.js';
import {TermFactory} from '../term/TermFactory.js';
import {Memory} from '../memory/Memory.js';
import {TaskManager} from '../task/TaskManager.js';
import {NarseseParser} from '../parser/NarseseParser.js';
import {PRIORITY} from '../config/constants.js';
import {BaseComponent} from '../util/BaseComponent.js';
import {ComponentManager} from '../util/ComponentManager.js';
import {Focus} from '../memory/Focus.js';
import {LM} from '../lm/LM.js';
import {Task} from '../task/Task.js';
import {Truth} from '../Truth.js';
import {ToolIntegration} from '../tool/ToolIntegration.js';
import {ExplanationService} from '../tool/ExplanationService.js';
import {EvaluationEngine} from '../reason/EvaluationEngine.js';
import {MetricsMonitor} from '../reason/MetricsMonitor.js';
import {EmbeddingLayer} from '../lm/EmbeddingLayer.js';
import {TermLayer} from '../memory/TermLayer.js';
import {ReasoningAboutReasoning} from '../self/ReasoningAboutReasoning.js';
import {ReasonerBuilder} from '../reason/index.js';

export class NAR extends BaseComponent {
    constructor(config = {}) {
        super(config, 'NAR');
        this._initializeCoreComponents(config);
        this._debugMode = this.config.debug?.pipeline || false;
    }

    get config() {
        return this._configManager.toJSON();
    }

    get memory() {
        return this._memory;
    }

    get isRunning() {
        return this._isRunning;
    }

    get cycleCount() {
        return this._streamReasoner?.metrics?.totalDerivations || 0;
    }

    get lm() {
        return this._lm;
    }

    get tools() {
        return this._toolIntegration;
    }

    get explanationService() {
        return this._explanationService;
    }

    get componentManager() {
        return this._componentManager;
    }

    get metricsMonitor() {
        return this._metricsMonitor;
    }

    get evaluator() {
        return this._evaluator;
    }

    get ruleEngine() {
        return this._ruleEngine;
    }

    get embeddingLayer() {
        return this._embeddingLayer;
    }

    get termLayer() {
        return this._termLayer;
    }

    get reasoningAboutReasoning() {
        return this._reasoningAboutReasoning;
    }

    get streamReasoner() {
        return this._streamReasoner;
    }

    _initializeCoreComponents(config) {
        this._configManager = new ConfigManager(config);
        this._componentManager = new ComponentManager({}, this._eventBus, this);
        this._initComponents();
        this._isRunning = false;
        this._startTime = Date.now();
        this._registerComponents();
        this._initStreamReasoner();

        if (this.config.components) {
            this._componentManager.loadComponentsFromConfig(this.config.components);
        }
    }

    async initialize() {
        const success = await this._componentManager.initializeAll();
        if (success) {
            await this._setupDefaultRules();
        }

        // Initialize stream reasoner if it's going to be used
        if (!this._streamReasoner) {
            this._initStreamReasoner();
            await this._registerRulesWithStreamReasoner();
        }

        return success;
    }

    _initComponents() {
        const {config} = this;
        const lmEnabled = config.lm?.enabled === true;

        this._termFactory = new TermFactory(config.termFactory, this._eventBus);
        this._memory = new Memory(config.memory);
        this._parser = new NarseseParser(this._termFactory);
        this._focus = new Focus(config.focus);
        this._taskManager = new TaskManager(this._memory, this._focus, config.taskManager);
        this._evaluator = new EvaluationEngine(null, this._termFactory);
        this._lm = lmEnabled ? new LM() : null;

        // Initialize stream reasoner components
        this._ruleEngine = null; // No old rule engine needed

        this._initOptionalComponents();
    }

    _initOptionalComponents() {
        const {config} = this;
        this._toolIntegration = config.tools?.enabled !== false ? new ToolIntegration(config.tools || {}) : null;

        if (this._toolIntegration) {
            this._toolIntegration.connectToReasoningCore(this);
            this._explanationService = new ExplanationService({lm: this._lm || null, ...config.tools?.explanation});
        }

        this._metricsMonitor = new MetricsMonitor({eventBus: this._eventBus, nar: this, ...config.metricsMonitor});
        const embeddingConfig = config.embeddingLayer || {enabled: false};
        this._embeddingLayer = embeddingConfig.enabled ? new EmbeddingLayer(embeddingConfig) : null;
        this._termLayer = new TermLayer({capacity: config.termLayer?.capacity || 1000, ...config.termLayer});
        this._reasoningAboutReasoning = new ReasoningAboutReasoning(this, {...config.reasoningAboutReasoning});
    }

    _initStreamReasoner() {
        this._streamReasoner = ReasonerBuilder.build(this);
    }

    _registerComponents() {
        this._componentManager.registerComponent('termFactory', {
            initialize: () => Promise.resolve(true),
            start: () => Promise.resolve(true),
            stop: () => Promise.resolve(true),
            dispose: () => Promise.resolve(true),
            isInitialized: true,
            isStarted: true,
            isDisposed: false
        });

        this._componentManager.registerComponent('memory', this._memory);
        this._componentManager.registerComponent('focus', this._focus, ['memory']);
        this._componentManager.registerComponent('taskManager', this._taskManager, ['memory', 'focus']);

        // Only register ruleEngine if it exists (for backward compatibility)
        if (this._ruleEngine) {
            this._componentManager.registerComponent('ruleEngine', this._ruleEngine);
        }

        if (this._lm) {
            this._componentManager.registerComponent('lm', this._lm);
        }

        if (this._toolIntegration) {
            this._componentManager.registerComponent('toolIntegration', this._toolIntegration);
            if (this._explanationService) {
                this._componentManager.registerComponent('explanationService', this._explanationService, ['toolIntegration']);
            }
        }
    }

    async _setupDefaultRules() {
        try {
            // Register rules with stream reasoner (the primary reasoner)
            await this._registerRulesWithStreamReasoner();
        } catch (error) {
            this.logWarn('Error setting up default rules:', error);
        }
    }

    async _registerRulesWithStreamReasoner() {
        if (!this._streamReasoner) return;
        await ReasonerBuilder.registerDefaultRules(this._streamReasoner, this.config);
    }

    async input(input, options = {}) {
        try {
            if (input instanceof Task) {
                return await this._processNewTask(input, 'user', input.toString(), null, options);
            }

            const narseseString = input;
            const parsed = this._parser.parse(narseseString);
            if (!parsed?.term) throw new Error('Invalid parse result');

            const task = this._createTask(parsed);
            return await this._processNewTask(task, 'user', narseseString, parsed, options);
        } catch (error) {
            this._eventBus.emit('input.error', {
                error: error.message,
                input: typeof input === 'string' ? input : 'Task Object'
            }, {traceId: options.traceId});
            throw error;
        }
    }

    async _processNewTask(task, source, originalInput, parsed, options = {}) {
        // Check if a semantically equivalent task already exists in memory
        if (this._isTaskDuplicate(task)) {
            return false;
        }

        const added = this._taskManager.addTask(task);

        if (added) {
            await this._emitTaskEvents(task, source, originalInput, parsed, options);
        }

        return added;
    }

    async _emitTaskEvents(task, source, originalInput, parsed, options) {
        this._eventBus.emit('task.input', {
            task,
            source,
            originalInput,
            parsed
        }, {traceId: options.traceId});

        if (this._focus) {
            const addedToFocus = this._focus.addTaskToFocus(task);
            if (addedToFocus) {
                this._eventBus.emit('task.focus', task, {traceId: options.traceId});
            }
        }

        await this._processPendingTasks(options.traceId);
    }

    _createTask(parsed) {
        const {term, truthValue, punctuation} = parsed;
        const budget = {priority: this._calculateInputPriority(parsed)};
        const taskType = this._getTaskTypeFromPunctuation(punctuation);

        return new Task({
            term,
            punctuation,
            truth: this._createTaskTruth(taskType, truthValue, parsed),
            budget,
        });
    }

    _createTaskTruth(taskType, truthValue, parsed) {
        if (taskType === 'QUESTION') {
            if (truthValue) {
                throw new Error(`Questions cannot have truth values: input was ${parsed.originalInput || 'unspecified'}`);
            }
            return null;
        }

        return truthValue ? new Truth(truthValue.frequency, truthValue.confidence) : new Truth(1.0, 0.9);
    }

    _getTaskTypeFromPunctuation = punctuation => ({
        '.': 'BELIEF',
        '!': 'GOAL',
        '?': 'QUESTION'
    })[punctuation] || 'BELIEF';

    start(options = {}) {
        if (this._isRunning) {
            this.logWarn('NAR already running');
            return false;
        }

        this._startComponentsAsync();
        this._isRunning = true;
        this._processPendingTasks(options.traceId);

        // Start the stream-based reasoner
        this._streamReasoner.start();

        // Set up monitoring process for stream reasoner metrics
        this._setupStreamMonitoring(options);

        this._eventBus.emit('system.started', {timestamp: Date.now()}, {traceId: options.traceId});
        this._emitIntrospectionEvent('system:start', {timestamp: Date.now()});
        this.logInfo(`NAR started successfully with stream-based reasoning`);
        return true;
    }

    _setupStreamMonitoring(options) {
        // Optionally, set up a monitoring process for stream reasoner metrics
        this._streamMonitoringInterval = setInterval(() => {
            if (this._streamReasoner) {
                const metrics = this._streamReasoner.getMetrics();
                this._eventBus.emit('streamReasoner.metrics', metrics, {traceId: options.traceId});
            }
        }, 5000); // Report metrics every 5 seconds
    }

    async _startComponentsAsync() {
        try {
            const success = await this._componentManager.startAll();
            if (!success) {
                this.logError('Failed to start all components');
            }
        } catch (error) {
            this.logError('Error during component start:', error);
        }
    }

    stop(options = {}) {
        if (!this._isRunning) {
            this.logWarn('NAR not running');
            return false;
        }

        this._isRunning = false;

        // Stop the stream-based reasoner
        this._stopStreamReasoner();

        // Clean up monitoring intervals
        this._cleanupMonitoring();

        // Ensure metrics monitor is stopped
        this._shutdownOptionalComponents();

        this._stopComponentsAsync();

        this._eventBus.emit('system.stopped', {timestamp: Date.now()}, {traceId: options.traceId});
        this._emitIntrospectionEvent('system:stop', {timestamp: Date.now()});
        this.logInfo(`NAR stopped successfully (stream-based reasoning)`);
        return true;
    }

    _stopStreamReasoner() {
        if (this._streamReasoner) {
            this._streamReasoner.stop();
        }
    }

    _cleanupMonitoring() {
        // Clear stream monitoring interval
        this._streamMonitoringInterval && clearInterval(this._streamMonitoringInterval) && (this._streamMonitoringInterval = null);
        // Ensure reasoning state interval is cleared
        this.disconnectFromWebSocketMonitor();
    }

    _shutdownOptionalComponents() {
        if (this._metricsMonitor?.shutdown) {
            this._metricsMonitor.shutdown();
        }
        if (this._reasoningAboutReasoning?.shutdown) {
            this._reasoningAboutReasoning.shutdown();
        }
    }

    async _stopComponentsAsync() {
        try {
            const success = await this._componentManager.stopAll();
            if (!success) {
                this.logError('Failed to stop all components');
            }
        } catch (error) {
            this.logError('Error during component stop:', error);
        }
    }

    async step(options = {}) {
        try {
            await this._processPendingTasks(options.traceId);

            const results = await this._streamReasoner.step();

            // Process all derivations through the same Input/Memory/Focus/Event process
            await this._processDerivations(results, options);

            this._eventBus.emit('streamReasoner.step', {
                results,
                count: results.length
            }, {traceId: options.traceId});
            return results;
        } catch (error) {
            this._eventBus.emit('streamReasoner.error', {error: error.message}, {traceId: options.traceId});
            this.logError('Error in reasoning step:', error);
            throw error;
        }
    }

    async _processDerivations(results, options) {
        for (const result of results) {
            if (result) {
                const added = await this._inputTask(result, {traceId: options.traceId});

                this._eventBus.emit('reasoning.derivation', {
                    derivedTask: result,
                    source: 'streamReasoner.step.method',
                    timestamp: Date.now()
                }, {traceId: options.traceId});
            }
        }
    }

    async runCycles(count, options = {}) {
        const results = [];
        for (let i = 0; i < count; i++) {
            try {
                results.push(await this.step({...options, cycleNumber: i + 1}));
            } catch (error) {
                results.push({error: error.message, cycleNumber: i + 1});
            }
        }
        return results;
    }

    async dispose() {
        // Stop reasoner if it's running
        if (this._isRunning) {
            this.stop();
        }

        // Clean up stream reasoner if it exists
        if (this._streamReasoner) {
            await this._streamReasoner.cleanup();
        }

        // Ensure metrics monitor is stopped
        if (this._metricsMonitor && typeof this._metricsMonitor.shutdown === 'function') {
            this._metricsMonitor.shutdown();
        }

        // Ensure reasoning about reasoning is stopped
        if (this._reasoningAboutReasoning && typeof this._reasoningAboutReasoning.shutdown === 'function') {
            this._reasoningAboutReasoning.shutdown();
        }

        const success = await this._componentManager.disposeAll();
        await super.dispose();
        return success;
    }

    serialize() {
        return {
            config: this.config,
            memory: this._memory.serialize ? this._memory.serialize() : null,
            taskManager: this._taskManager.serialize ? this._taskManager.serialize() : null,
            focus: this._focus.serialize ? this._focus.serialize() : null,
            cycleCount: this.cycleCount,
            isRunning: this._isRunning,
            timestamp: Date.now(),
            version: '10.0.0'
        };
    }

    getConcepts() {
        if (this._memory) {
            return this._memory.getAllConcepts();
        }
        return [];
    }

    getConceptByName(termString) {
        if (this._memory) {
            for (const concept of this._memory.getAllConcepts()) {
                if (concept.term.toString() === termString) {
                    return concept;
                }
            }
        }
        return null;
    }

    getConceptPriorities() {
        if (this._memory) {
            return this._memory.getAllConcepts().map(concept => ({
                term: concept.term.toString(),
                priority: concept.priority || concept.activation || 0,
                activation: concept.activation || 0,
                useCount: concept.useCount || 0,
                quality: concept.quality || 0,
                totalTasks: concept.totalTasks || 0
            }));
        }
        return [];
    }

    async deserialize(state) {
        try {
            if (this._isRunning) {
                this.stop();
            }

            if (state.config) {
                this._configManager = new ConfigManager(state.config);
            }

            if (state.memory && this._memory.deserialize) {
                await this._memory.deserialize(state.memory);
            }

            if (state.taskManager && this._taskManager.deserialize) {
                await this._taskManager.deserialize(state.taskManager);
            }

            if (state.focus && this._focus.deserialize) {
                await this._focus.deserialize(state.focus);
            }

            if (state.isRunning !== undefined) {
                this._isRunning = state.isRunning;
            }

            await this._componentManager.disposeAll();
            this._initComponents();
            await this._componentManager.initializeAll();
            await this._setupDefaultRules();

            this._eventBus.emit('system.loaded', {
                timestamp: Date.now(),
                stateVersion: state.version,
                fromFile: state.sourceFile || 'serialized'
            });

            return true;
        } catch (error) {
            this.logError('Error during NAR deserialization:', error);
            return false;
        }
    }

    query(queryTerm) {
        return this._memory.getConcept(queryTerm)?.getTasksByType('BELIEF') || [];
    }

    getBeliefs(queryTerm = null) {
        return queryTerm ? this.query(queryTerm)
            : this._memory.getAllConcepts().flatMap(c => c.getTasksByType('BELIEF'));
    }

    async ask(task) {
        if (!this._streamReasoner) {
            throw new Error('Stream reasoner is not initialized.');
        }
        return this._streamReasoner.strategy.ask(task);
    }

    getGoals() {
        return this._taskManager.findTasksByType('GOAL');
    }

    getQuestions() {
        return this._taskManager.findTasksByType('QUESTION');
    }

    reset(options = {}) {
        this.stop();
        this._memory.clear();
        this._taskManager.clearPendingTasks();
        this._eventBus.emit('system.reset', {timestamp: Date.now()}, {traceId: options.traceId});
        this.logInfo('NAR reset completed');
    }

    on(eventName, callback) {
        this._eventBus.on(eventName, callback);
    }

    off(eventName, callback) {
        this._eventBus.off(eventName, callback);
    }

    getStats() {
        const baseStats = {
            isRunning: this._isRunning,
            cycleCount: this._streamReasoner?.metrics?.totalDerivations || 0,
            memoryStats: this._memory.getDetailedStats(),
            taskManagerStats: this._taskManager.getTaskStats?.() ?? this._taskManager.stats,
            config: this.config,
            lmStats: this._lm?.getMetrics?.()
        };

        baseStats.streamReasonerStats = this._streamReasoner?.getMetrics?.() || null;

        return baseStats;
    }

    _withComponentCheck(component, message, operation) {
        if (!component) throw new Error(message);
        return operation(component);
    }

    _ensureLMEnabled() {
        if (!this._lm) throw new Error('Language Model is not enabled in this NAR instance');
    }

    _ensureToolIntegration() {
        if (!this._toolIntegration) throw new Error('Tool integration is not enabled');
    }

    _ensureExplanationService() {
        if (!this._explanationService) throw new Error('Explanation service is not enabled');
    }

    registerLMProvider(id, provider) {
        this._ensureLMEnabled();
        this._lm.registerProvider(id, provider);
        return this;
    }

    async generateWithLM(prompt, options = {}) {
        return this._withComponentCheck(this._lm, 'Language Model is not enabled in this NAR instance',
            lm => lm.generateText(prompt, options));
    }

    translateToNarsese(text) {
        return this._withComponentCheck(this._lm, 'Language Model is not enabled in this NAR instance',
            lm => lm.translateToNarsese(text));
    }

    translateFromNarsese(narsese) {
        return this._withComponentCheck(this._lm, 'Language Model is not enabled in this NAR instance',
            lm => lm.translateFromNarsese(narsese));
    }

    _calculateInputPriority(parsed) {
        const {truthValue, taskType} = parsed;
        const basePriority = this.config.taskManager?.defaultPriority || PRIORITY.DEFAULT;

        if (!truthValue) return basePriority;

        const priorityConfig = this.config.taskManager?.priority || {};
        const {confidenceMultiplier = 0.3, goalBoost = 0.2, questionBoost = 0.1} = priorityConfig;

        const confidenceBoost = (truthValue.confidence || 0) * confidenceMultiplier;
        const typeBoost = {GOAL: goalBoost, QUESTION: questionBoost}[taskType] || 0;

        return Math.min(PRIORITY.MAX_PRIORITY, basePriority + confidenceBoost + typeBoost);
    }

    async _processPendingTasks(traceId) {
        for (const task of this._taskManager.processPendingTasks(Date.now())) {
            this._eventBus.emit('task.added', {task}, {traceId});
        }
    }

    connectToWebSocketMonitor(monitor) {
        if (!monitor || typeof monitor.listenToNAR !== 'function') {
            throw new Error('Invalid WebSocket monitor provided');
        }

        monitor.listenToNAR(this);
        this.logInfo('Connected to WebSocket monitor for real-time monitoring');

        if (this._reasoningAboutReasoning) {
            this._reasoningStateInterval = setInterval(() => {
                this._emitPeriodicReasoningState();
            }, 5000);
        }
    }

    _emitPeriodicReasoningState() {
        try {
            if (this._reasoningAboutReasoning?.getReasoningState) {
                const state = this._reasoningAboutReasoning.getReasoningState();
                this._eventBus.emit('reasoningState', state, {source: 'periodic'});
            }
        } catch (error) {
            this.logError('Error in reasoning state update:', error);
        }
    }

    disconnectFromWebSocketMonitor() {
        if (this._reasoningStateInterval) {
            clearInterval(this._reasoningStateInterval);
            this._reasoningStateInterval = null;
        }
    }

    getReasoningState() {
        return this._reasoningAboutReasoning?.getReasoningState?.() ?? null;
    }

    async initializeTools() {
        if (this._toolIntegration) {
            await this._toolIntegration.initializeTools(this);
            this.logger.info('Tools initialized successfully');
            return true;
        }
        return false;
    }

    getMetrics() {
        return this._metricsMonitor ? this._metricsMonitor.getMetricsSnapshot() : null;
    }

    performSelfOptimization() {
        if (this._metricsMonitor) {
            this._metricsMonitor._performSelfOptimization();
        }
    }

    async solveEquation(leftTerm, rightTerm, variableName, context = null) {
        const evaluationContext = context || {
            memory: this._memory,
            termFactory: this._termFactory
        };

        // Use the evaluator that's available
        if (this._evaluator) {
            return await this._evaluator.solveEquation(
                leftTerm,
                rightTerm,
                variableName,
                evaluationContext
            );
        }

        return {
            result: null,
            success: false,
            message: 'No operation evaluation engine available'
        };
    }

    async performMetaCognitiveReasoning() {
        return this._reasoningAboutReasoning ? await this._reasoningAboutReasoning.performMetaCognitiveReasoning() : null;
    }

    async performSelfCorrection() {
        return this._reasoningAboutReasoning ? await this._reasoningAboutReasoning.performSelfCorrection() : null;
    }

    querySystemState(query) {
        return this._reasoningAboutReasoning?.querySystemState(query) ?? null;
    }

    getReasoningTrace() {
        return this._reasoningAboutReasoning?.getReasoningTrace() ?? [];
    }

    async executeTool(toolId, params, context = {}) {
        const startTime = Date.now();
        try {
            const result = await this._withComponentCheck(this._toolIntegration, 'Tool integration is not enabled',
                toolIntegration => toolIntegration.executeTool(toolId, params, this._createToolContext(context)));
            const duration = Date.now() - startTime;
            duration > 1000 && this.logger.warn(`Slow tool execution: ${toolId} took ${duration}ms`, {
                toolId,
                duration,
                paramsSize: JSON.stringify(params).length
            });
            return result;
        } catch (error) {
            this.logger.error(`Tool execution failed: ${toolId}`, {
                toolId,
                error: error.message,
                duration: Date.now() - startTime
            });
            throw error;
        }
    }

    async executeTools(toolCalls, context = {}) {
        return await this._withComponentCheck(this._toolIntegration, 'Tool integration is not enabled',
            toolIntegration => toolIntegration.executeTools(toolCalls, this._createToolContext(context)));
    }

    getAvailableTools() {
        return this._toolIntegration?.getAvailableTools() ?? [];
    }

    async explainToolResult(toolResult, context = {}) {
        return await this._withComponentCheck(this._explanationService, 'Explanation service is not enabled',
            service => service.explainToolResult(toolResult, this._createToolContext(context)));
    }

    async explainToolResults(toolResults, context = {}) {
        return await this._withComponentCheck(this._explanationService, 'Explanation service is not enabled',
            service => service.explainToolResults(toolResults, this._createToolContext(context)));
    }

    async summarizeToolExecution(toolResults, context = {}) {
        return await this._withComponentCheck(this._explanationService, 'Explanation service is not enabled',
            service => service.summarizeToolExecution(toolResults, this._createToolContext(context)));
    }

    async assessToolResults(toolResults, context = {}) {
        return await this._withComponentCheck(this._explanationService, 'Explanation service is not enabled',
            service => service.assessToolResults(toolResults, this._createToolContext(context)));
    }

    _createToolContext = (context = {}) => ({
        nar: this,
        memory: this._memory,
        timestamp: Date.now(),
        ...context
    });

    // Check if a semantically equivalent task already exists in memory
    _isTaskDuplicate(task) {
        const existingConcept = this._memory.getConcept(task.term);
        if (existingConcept) {
            const storage = existingConcept._getStorage(task.type);
            for (const [existingTask] of storage._items) {
                if (task.equals(existingTask)) {
                    return true;
                }
            }
        }
        return false;
    }

    // Internal method to input an already-constructed Task object following the same
    // Input/Memory/Focus/Event process as the main input method
    async _inputTask(task, options = {}) {
        try {
            return await this._processNewTask(task, 'derived', null, null, options);
        } catch (error) {
            this._eventBus.emit('input.error', {
                error: error.message,
                input: 'derived-task'
            }, {traceId: options.traceId});
            throw error;
        }
    }


}

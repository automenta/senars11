#!/usr/bin/env node

import {spawn} from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import {fileURLToPath} from 'url';
import net from 'net';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');

const args = process.argv.slice(2);
const parallel = args.includes('--parallel') || args.includes('-p');
const timedMode = args.includes('--timed') || args.includes('--time');
const logOnlyMode = args.includes('--log-only') || args.includes('-l');

const TOURS = [
    {id: 'basic-reasoning', duration: 30000},
    {id: 'decision-making', duration: 30000},
    {id: 'syllogistic-reasoning', duration: 30000},
    {id: 'temporal-reasoning', duration: 30000},
    {id: 'operator-examples', duration: 30000},
    {id: 'multi-step-inference', duration: 40000},
    {id: 'hybrid-reasoning', duration: 40000},
    {id: 'procedural-learning', duration: 30000},
    {id: 'causal-reasoning', duration: 30000},
    {id: 'truth-value-reasoning', duration: 30000}
];

const children = [];

async function getFreePort(startPort) {
    let port = startPort;
    while (true) {
        if (await isPortFree(port)) return port;
        port++;
    }
}

function isPortFree(port) {
    return new Promise((resolve) => {
        const server = net.createServer();
        server.listen(port, () => {
            server.close(() => resolve(true));
        });
        server.on('error', () => resolve(false));
    });
}

async function runCommand(command, args, options = {}) {
    return new Promise((resolve, reject) => {
        const proc = spawn(command, args, {
            stdio: 'inherit',
            ...options
        });

        proc.on('close', (code) => {
            if (code === 0) resolve();
            else reject(new Error(`Command ${command} exited with code ${code}`));
        });

        proc.on('error', (err) => reject(err));
    });
}

async function runTour(tour, uiPort, wsPort) {
    console.log(`\nStarting Tour: ${tour.id} (UI: ${uiPort}, WS: ${wsPort})`);

    const outputDir = path.join(rootDir, 'test-results', tour.id);
    const screenshotsDir = path.join(outputDir, 'screenshots');
    const logFile = path.join(outputDir, 'demo.log');

    await fs.mkdir(outputDir, {recursive: true});

    const logStream = await fs.open(logFile, 'w');

    // Start Server
    const serverProcess = spawn('node', [
        'scripts/ui/launcher.js',
        '--demo', tour.id,
        '--port', uiPort.toString(),
        '--ws-port', wsPort.toString(),
        '--provider', 'dummy',
        '--no-open'
    ], {
        cwd: rootDir,
        stdio: ['ignore', logStream.fd, logStream.fd]
    });

    children.push(serverProcess);

    console.log(`Server started for ${tour.id} (PID: ${serverProcess.pid})`);

    try {
        // Wait for readiness
        if (!await waitForServerReady(wsPort)) {
            throw new Error(`Server for ${tour.id} failed to become ready`);
        }

        console.log(`Server ready for ${tour.id}`);

        if (logOnlyMode) {
             await waitForCompletion(wsPort, tour.id, tour.duration || 30000);
        } else {
            // Visualization
            if (timedMode) {
                await runCommand('node', [
                    'scripts/utils/visualize.js',
                    '--type', 'screenshots',
                    '--duration', tour.duration.toString(),
                    '--interval', '1500',
                    '--url', `http://localhost:${uiPort}`,
                    '--output', screenshotsDir
                ], {cwd: rootDir});
            } else {
                await runEventDrivenScreenshots(tour, screenshotsDir, wsPort, `http://localhost:${uiPort}`);
            }
        }

        // CPU Usage check
        try {
             const ps = spawn('ps', ['-p', serverProcess.pid, '-o', '%cpu']);
             let psOutput = '';
             ps.stdout.on('data', d => psOutput += d);
             await new Promise(r => ps.on('close', r));
             const cpuUsage = psOutput.trim().split('\n')[1]?.trim() || 'Unknown';
             await fs.appendFile(logFile, `\nFinal CPU Usage: ${cpuUsage}%\n`);
        } catch (e) {}

    } finally {
        serverProcess.kill();
        const idx = children.indexOf(serverProcess);
        if (idx > -1) children.splice(idx, 1);
        await logStream.close();
    }

    // Composite generation
    if (!logOnlyMode) {
        try {
            await runCommand('node', [
                'scripts/utils/generate-composite.js',
                '--input', screenshotsDir,
                '--output', outputDir
            ], {cwd: rootDir});
        } catch (e) {
            console.error(`Composite generation failed for ${tour.id}:`, e.message);
        }
    }
}

async function waitForServerReady(wsPort, timeout = 30000) {
    const WebSocket = (await import('ws')).default;
    const start = Date.now();

    while (Date.now() - start < timeout) {
        try {
            await new Promise((resolve, reject) => {
                const ws = new WebSocket(`ws://localhost:${wsPort}/ws`);
                ws.on('open', () => {
                    ws.close();
                    resolve();
                });
                ws.on('error', reject);
            });
            return true;
        } catch (e) {
            await new Promise(r => setTimeout(r, 500));
        }
    }
    return false;
}

async function waitForCompletion(wsPort, demoId, timeout) {
    return runEventDrivenScreenshots({id: demoId}, null, wsPort, null, timeout, true);
}

async function runEventDrivenScreenshots(tour, screenshotsDir, wsPort, url, maxDuration = 20000, noScreenshots = false) {
    const WebSocket = (await import('ws')).default;
    const ws = new WebSocket(`ws://localhost:${wsPort}/ws`);

    let screenshotCount = 0;
    const promises = [];

    return new Promise((resolve) => {
        const timer = setTimeout(() => {
            ws.terminate();
            resolve();
        }, maxDuration);

        ws.on('open', () => {
             ws.send(JSON.stringify({
                type: 'subscribe',
                eventTypes: ['demoState', 'nar.cycle.step', 'reasoning.derivation']
            }));
        });

        ws.on('message', async (data) => {
            try {
                const msg = JSON.parse(data.toString());

                if (msg.type === 'demoState' && (msg.payload.state === 'completed' || msg.payload.state === 'error')) {
                    clearTimeout(timer);
                    ws.terminate();
                    resolve();
                    return;
                }

                if (!noScreenshots && msg.type && ['nar.cycle.step', 'reasoning.derivation'].includes(msg.type)) {
                    screenshotCount++;
                    const p = runCommand('node', [
                        'scripts/utils/visualize.js',
                        '--type', 'single-screenshot',
                        '--url', url,
                        '--output', path.join(screenshotsDir, `shot_${screenshotCount.toString().padStart(3,'0')}.png`)
                    ], {cwd: rootDir});
                    promises.push(p);

                    if (screenshotCount >= 20) {
                        clearTimeout(timer);
                        ws.terminate();
                        resolve();
                    }
                }
            } catch (e) {}
        });

        ws.on('error', () => {
            clearTimeout(timer);
            resolve();
        });
    });
}

async function main() {
    const specified = args.filter(a => !a.startsWith('-'));
    const toursToRun = specified.length ? TOURS.filter(t => specified.includes(t.id)) : TOURS;

    if (toursToRun.length === 0) {
        console.error('No matching tours found.');
        process.exit(1);
    }

    process.on('SIGINT', () => { children.forEach(p => p.kill()); process.exit(); });

    if (parallel) {
        const promises = [];
        let basePort = 3000;

        for (const tour of toursToRun) {
            const uiPort = await getFreePort(basePort);
            const wsPort = await getFreePort(uiPort + 1);
            basePort = wsPort + 1;

            promises.push(runTour(tour, uiPort, wsPort).catch(e => console.error(e)));
        }
        await Promise.all(promises);
    } else {
        for (const tour of toursToRun) {
            const uiPort = await getFreePort(5173);
            const wsPort = await getFreePort(8080);
            await runTour(tour, uiPort, wsPort);
        }
    }
    console.log('Done.');
}

main();

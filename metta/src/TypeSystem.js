/**
 * TypeSystem.js - Gradual dependent type system for MeTTa
 * Implements Hindley-Milner style type inference with dependent types
 * Following AGENTS.md: Elegant, Consolidated, Consistent, Organized, Deeply deduplicated
 */

import { Term } from './kernel/Term.js';

/**
 * Type constructor factory functions
 */
export const TypeConstructors = {
    Base: (name) => ({ kind: 'Base', name }),
    Arrow: (from, to) => ({ kind: 'Arrow', from, to }),
    List: (element) => ({ kind: 'List', element }),
    Maybe: (type) => ({ kind: 'Maybe', type }),
    Either: (left, right) => ({ kind: 'Either', left, right }),
    Vector: (length) => ({ kind: 'Vector', length }),
    Fin: (n) => ({ kind: 'Fin', n }),
    TypeVar: (index) => ({ kind: 'TypeVar', index }),
    Forall: (varName, type) => ({ kind: 'Forall', varName, type }),
    TypeCtor: (name, params = []) => ({ kind: 'TypeCtor', name, params })
};

// Base types
const BaseTypes = {
    Number: TypeConstructors.Base('Number'),
    String: TypeConstructors.Base('String'),
    Bool: TypeConstructors.Base('Bool'),
    Atom: TypeConstructors.Base('Atom')
};
Object.assign(TypeConstructors, BaseTypes);

export class TypeSystem {
    constructor() {
        this.typeRegistry = new Map(Object.entries(BaseTypes).map(([k, v]) => [k, v]));
        this.substitution = new Map();
        this.nextTypeVarId = 0;
    }

    /**
     * Generate a fresh type variable
     */
    freshTypeVar() {
        return TypeConstructors.TypeVar(this.nextTypeVarId++);
    }

    /**
     * Infer the type of a term
     */
    inferType(term, context = {}) {
        if (!term) return this.freshTypeVar();

        if (term.type === 'atom') {
            // Handle variable atoms
            if (term.name?.match(/^[?$]/)) {
                const name = term.name.substring(1);
                return context[name] || this.freshTypeVar();
            }

            // Handle constant atoms
            if (term.name) {
                if (!isNaN(parseFloat(term.name))) return TypeConstructors.Number;
                if (/^(True|False|true|false)$/.test(term.name)) return TypeConstructors.Bool;
                if (term.name.startsWith('"')) return TypeConstructors.String;
                return TypeConstructors.Atom;
            }
        }

        // Handle compound terms (expressions)
        if (term.type === 'compound' && term.operator) {
            const opType = this.inferType(term.operator, context);
            const argTypes = term.components.map(arg => this.inferType(arg, context));

            // If operator is a function type and we have exactly one argument that unifies with the domain
            if (opType.kind === 'Arrow' && argTypes.length === 1 && this.unifyTypes(argTypes[0], opType.from)) {
                return opType.to;
            }
        }

        return this.freshTypeVar();
    }

    /**
     * Check if a term has a specific type
     */
    checkType(term, expectedType, context = {}) {
        return this.unifyTypes(this.inferType(term, context), expectedType);
    }

    /**
     * Unify two types
     */
    unifyTypes(t1, t2) {
        if (t1 === t2) return true;
        if (t1.kind === 'TypeVar') return this.bindTypeVar(t1, t2);
        if (t2.kind === 'TypeVar') return this.bindTypeVar(t2, t1);

        if (t1.kind !== t2.kind) return false;

        switch (t1.kind) {
            case 'Base':
                return t1.name === t2.name;
            case 'Arrow':
                return this.unifyTypes(t1.from, t2.from) && this.unifyTypes(t1.to, t2.to);
            case 'List':
                return this.unifyTypes(t1.element, t2.element);
            case 'TypeCtor':
                return t1.name === t2.name &&
                    t1.params.length === t2.params.length &&
                    t1.params.every((p, i) => this.unifyTypes(p, t2.params[i]));
            default:
                return false;
        }
    }

    /**
     * Bind a type variable to a type
     */
    bindTypeVar(v, t) {
        if (this.occursCheck(v, t)) return false;
        this.substitution.set(v.index, t);
        return true;
    }

    /**
     * Check if a type variable occurs in a type (to prevent infinite types)
     */
    occursCheck(v, t) {
        if (t.kind === 'TypeVar') return t.index === v.index;
        if (t.kind === 'Arrow') return this.occursCheck(v, t.from) || this.occursCheck(v, t.to);
        if (t.kind === 'List') return this.occursCheck(v, t.element);
        if (t.kind === 'TypeCtor') return t.params.some(p => this.occursCheck(v, p));
        return false;
    }

    /**
     * Apply substitutions to a type
     */
    applySubstitution(type) {
        if (type.kind === 'TypeVar') {
            const subst = this.substitution.get(type.index);
            return subst ? this.applySubstitution(subst) : type;
        }

        switch (type.kind) {
            case 'Arrow':
                return TypeConstructors.Arrow(
                    this.applySubstitution(type.from),
                    this.applySubstitution(type.to)
                );
            case 'List':
                return TypeConstructors.List(this.applySubstitution(type.element));
            case 'TypeCtor':
                return TypeConstructors.TypeCtor(
                    type.name,
                    type.params.map(p => this.applySubstitution(p))
                );
            default:
                return type;
        }
    }

    /**
     * Generate type constraints for a term
     */
    generateConstraints(term, context = {}) {
        const constraints = [];
        if (term.type === 'compound' && term.operator) {
            const funcType = this.inferType(term.operator, context);
            const resultType = this.freshTypeVar();

            term.components.forEach(arg => {
                constraints.push({
                    type1: funcType,
                    type2: TypeConstructors.Arrow(this.inferType(arg, context), resultType)
                });
            });

            constraints.push({ type1: this.inferType(term, context), type2: resultType });
        }
        return constraints;
    }

    /**
     * Solve type constraints
     */
    solveConstraints(constraints) {
        return constraints.every(c => this.unifyTypes(c.type1, c.type2));
    }

    /**
     * Infer type with constraint solving
     */
    inferWithConstraints(term, context = {}) {
        const constraints = this.generateConstraints(term, context);
        if (!this.solveConstraints(constraints)) {
            throw new Error(`Type inference failed: ${term.toString()}`);
        }
        return this.applySubstitution(this.inferType(term, context));
    }

    /**
     * Convert a type to string representation
     */
    typeToString(type) {
        if (!type) return 'Unknown';
        switch (type.kind) {
            case 'Base': return type.name;
            case 'Arrow': return `(${this.typeToString(type.from)} -> ${this.typeToString(type.to)})`;
            case 'List': return `(List ${this.typeToString(type.element)})`;
            case 'Maybe': return `(Maybe ${this.typeToString(type.type)})`;
            case 'Either': return `(Either ${this.typeToString(type.left)} ${this.typeToString(type.right)})`;
            case 'Vector': return `(Vector ${type.length})`;
            case 'Fin': return `(Fin ${type.n})`;
            case 'TypeVar': return `t${type.index}`;
            case 'Forall': return `(âˆ€ ${type.varName} ${this.typeToString(type.type)})`;
            case 'TypeCtor':
                const params = type.params.map(p => this.typeToString(p)).join(' ');
                return `(${type.name}${params ? ' ' + params : ''})`;
            default: return 'Unknown';
        }
    }
}

export class TypeChecker {
    constructor(typeSystem) {
        this.typeSystem = typeSystem || new TypeSystem();
    }

    /**
     * Infer the type of a term
     */
    infer(term, context = {}) {
        return this.typeSystem.inferWithConstraints(term, context);
    }

    /**
     * Check if a term has a specific type
     */
    check(term, expectedType, context = {}) {
        return this.typeSystem.checkType(term, expectedType, context);
    }

    /**
     * Unify two types and return the resulting substitution
     */
    unify(type1, type2) {
        const tempSystem = new TypeSystem();
        tempSystem.substitution = new Map(this.typeSystem.substitution);
        tempSystem.nextTypeVarId = this.typeSystem.nextTypeVarId;
        return tempSystem.unifyTypes(type1, type2) ? tempSystem.substitution : null;
    }

    /**
     * Convert a type to string representation
     */
    typeToString(type) {
        return this.typeSystem.typeToString(type);
    }
}
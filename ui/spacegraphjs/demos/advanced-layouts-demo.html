<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>Advanced Layouts Demo - SpaceGraphJS</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0f0f1a;
            color: white;
            font-family: Arial, sans-serif;
        }
        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
        }
        h3 {
            margin-top: 0;
            color: #4CAF50;
        }
    </style>
</head>
<body>
<div id="container">
    <div id="info">
        <h3>Advanced Layout Systems</h3>
        <p>Demonstrates next-generation layout capabilities including constraint-based positioning, nested container layouts, adaptive layout selection, and inter-layout connectivity.</p>
        <ul>
            <li>Constraint-based layouts with distance, position, and angle constraints</li>
            <li>Nested container layouts with hierarchical arrangement</li>
            <li>Adaptive layouts that automatically select optimal arrangements</li>
            <li>Layout connectors for visualizing relationships between layout regions</li>
            <li>Morphing transitions between different layout types</li>
            <li>Hybrid layout modes combining multiple layout systems</li>
            <li>Basic TreeMapLayout and RadialLayout (experimental stubs)</li>
        </ul>
    </div>
    <canvas id="webgl-canvas"></canvas>
    <div id="css3d-container"></div>
</div>

<script type="module">
    import {SpaceGraph} from '../src/index.js';

    async function init() {
        const container = document.getElementById('container');

        // Initialize SpaceGraph with ergonomic factory method
        const space = await SpaceGraph.the(container);
        
        
        // Advanced Layouts Demo Implementation
        const nodes = [];
        const edges = [];
        const containers = [];
        let layoutManager = space.layoutManager;

        // Create UI panel
        const ui = document.createElement('div');
        ui.style.cssText = `
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            color: white;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            min-width: 300px;
            backdrop-filter: blur(10px);
            z-index: 1000;
        `;

        ui.innerHTML = `
            <h3 style="margin: 0 0 15px 0; color: #64B5F6;">Advanced Layout Systems</h3>

            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 8px; color: #B3E5FC;">Layout Type:</label>
                <select id="layoutType" style="width: 100%; padding: 6px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 4px;">
                    <option value="force">Force Layout</option>
                    <option value="hierarchical">Hierarchical</option>
                    <option value="circular">Circular</option>
                    <option value="grid">Grid</option>
                    <option value="spherical">Spherical</option>
                    <option value="radial">Radial (Experimental)</option>
                    <option value="treemap">TreeMap (Experimental)</option>
                    <option value="constraint">Constraint-Based</option>
                    <option value="nested">Nested Containers</option>
                    <option value="adaptive">Adaptive</option>
                    <option value="hybrid">Hybrid Mode</option>
                </select>
            </div>

            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 8px; color: #B3E5FC;">Layout Mode:</label>
                <select id="layoutMode" style="width: 100%; padding: 6px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 4px;">
                    <option value="standard">Standard</option>
                    <option value="constraint">Constraint</option>
                    <option value="nested">Nested</option>
                    <option value="adaptive">Adaptive</option>
                    <option value="hybrid">Hybrid</option>
                </select>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                <button id="applyLayout" style="padding: 8px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">Apply Layout</button>
                <button id="morphLayouts" style="padding: 8px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Morph Demo</button>
            </div>

            <div style="margin-bottom: 15px;">
                <h4 style="margin: 0 0 10px 0; color: #81C784;">Features:</h4>
                <label style="display: block; margin-bottom: 5px;">
                    <input type="checkbox" id="enableConstraints" style="margin-right: 8px;"> Constraints
                </label>
                <label style="display: block; margin-bottom: 5px;">
                    <input type="checkbox" id="enableNesting" style="margin-right: 8px;"> Nesting
                </label>
                <label style="display: block; margin-bottom: 5px;">
                    <input type="checkbox" id="enableAdaptive" style="margin-right: 8px;"> Adaptive
                </label>
                <label style="display: block; margin-bottom: 5px;">
                    <input type="checkbox" id="enableConnections" checked style="margin-right: 8px;"> Connections
                </label>
            </div>

            <div style="margin-bottom: 15px;">
                <h4 style="margin: 0 0 10px 0; color: #FFB74D;">Actions:</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <button id="addConstraint" style="padding: 6px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Add Constraint</button>
                    <button id="addContainer" style="padding: 6px; background: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Add Container</button>
                    <button id="forceAdapt" style="padding: 6px; background: #E91E63; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Force Adapt</button>
                    <button id="showConnections" style="padding: 6px; background: #00BCD4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Show Connections</button>
                </div>
            </div>

            <div id="layoutInfo" style="background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 6px; font-size: 11px;">
                <div id="currentLayout">Current: Standard</div>
                <div id="nodeCount">Nodes: 0</div>
                <div id="edgeCount">Edges: 0</div>
                <div id="layoutMetrics">Density: 0.00</div>
            </div>
        `;

        document.body.appendChild(ui);

        // Create demo graph
        function createDemoGraph() {
            // Create main cluster of nodes
            for (let i = 0; i < 20; i++) {
                const node = space.createNode({
                    id: `node_${i}`,
                    type: i % 4 === 0 ? 'shape' : 'html',
                    position: {
                        x: (Math.random() - 0.5) * 400,
                        y: (Math.random() - 0.5) * 400,
                        z: (Math.random() - 0.5) * 200,
                    },
                    data: {
                        group: i < 10 ? 'A' : 'B',
                        mass: 1 + Math.random() * 2,
                        clusterId: Math.floor(i / 5),
                        label: `Node ${i}`,
                        shape: 'sphere',
                        size: 20,
                        color: Math.floor(Math.random() * 0xffffff)
                    },
                });
                nodes.push(node);
            }

            // Create hierarchical structure
            for (let i = 20; i < 30; i++) {
                const parentIndex = Math.floor((i - 20) / 3);
                const parent = nodes[parentIndex];

                const node = space.createNode({
                    id: `hierarchy_${i}`,
                    type: 'shape',
                    position: {
                        x: parent.position.x + (Math.random() - 0.5) * 100,
                        y: parent.position.y - 100,
                        z: parent.position.z + (Math.random() - 0.5) * 50,
                    },
                    data: {
                        group: 'hierarchy',
                        label: `HNode ${i}`,
                        shape: 'box',
                        size: 15,
                        color: Math.floor(Math.random() * 0xffffff)
                    },
                });
                nodes.push(node);

                // Create edge to parent
                const edge = space.addEdge(parent, node, {
                    label: `Edge ${i}`,
                    color: 0x888888,
                    thickness: 1
                });
                edges.push(edge);
            }

            // Create some random connections
            for (let i = 0; i < 25; i++) {
                const source = nodes[Math.floor(Math.random() * nodes.length)];
                const target = nodes[Math.floor(Math.random() * nodes.length)];

                if (source !== target && !hasEdge(source, target)) {
                    const edge = space.addEdge(source, target, {
                        label: `Edge ${i}`,
                        color: 0xaaaaaa,
                        thickness: 1
                    });
                    edges.push(edge);
                }
            }

            updateLayoutInfo();
        }

        function hasEdge(source, target) {
            return edges.some(
                edge =>
                    (edge.source === source && edge.target === target) ||
                    (edge.source === target && edge.target === source)
            );
        }

        function updateLayoutInfo() {
            const nodeCount = nodes.length;
            const edgeCount = edges.length;
            const density = nodeCount > 1 ? edgeCount / ((nodeCount * (nodeCount - 1)) / 2) : 0;

            document.getElementById('currentLayout').textContent = `Current: Standard`;
            document.getElementById('nodeCount').textContent = `Nodes: ${nodeCount}`;
            document.getElementById('edgeCount').textContent = `Edges: ${edgeCount}`;
            document.getElementById('layoutMetrics').textContent = `Density: ${density.toFixed(2)}`;
        }

        // Event listeners
        document.getElementById('applyLayout').addEventListener('click', () => {
            const layoutType = document.getElementById('layoutType').value;
            const layoutMode = document.getElementById('layoutMode').value;
            applySelectedLayout(layoutType, layoutMode);
        });

        document.getElementById('morphLayouts').addEventListener('click', () => {
            demonstrateMorphing();
        });

        document.getElementById('enableConstraints').addEventListener('change', e => {
            console.log('Constraints feature:', e.target.checked);
        });

        document.getElementById('enableNesting').addEventListener('change', e => {
            console.log('Nesting feature:', e.target.checked);
        });

        document.getElementById('enableAdaptive').addEventListener('change', e => {
            console.log('Adaptive feature:', e.target.checked);
        });

        document.getElementById('enableConnections').addEventListener('change', e => {
            console.log('Connections feature:', e.target.checked);
        });

        document.getElementById('addConstraint').addEventListener('click', () => {
            addRandomConstraint();
        });

        document.getElementById('addContainer').addEventListener('click', () => {
            addContainerNode();
        });

        document.getElementById('forceAdapt').addEventListener('click', () => {
            forceAdaptation();
        });

        document.getElementById('showConnections').addEventListener('click', () => {
            showLayoutConnections();
        });

        function applySelectedLayout(layoutType, layoutMode) {
            // Apply the selected layout using the layout manager
            space.layoutManager?.applyLayout(layoutType, {
                animate: true,
                animationDuration: 0.8
            });
        }

        async function demonstrateMorphing() {
            const layouts = ['circular', 'grid', 'force', 'hierarchical'];
            
            for (const layout of layouts) {
                applySelectedLayout(layout, 'standard');
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }

        function addRandomConstraint() {
            if (nodes.length < 2) return;

            const node1 = nodes[Math.floor(Math.random() * nodes.length)];
            const node2 = nodes[Math.floor(Math.random() * nodes.length)];
            
            if (node1 !== node2) {
                // For simplicity, we'll just log the constraint addition
                console.log(`Added distance constraint between ${node1.id} and ${node2.id}`);
            }
        }

        function addContainerNode() {
            const containerNode = space.createNode({
                id: `container_${Date.now()}`,
                type: 'html',
                position: {
                    x: (Math.random() - 0.5) * 200,
                    y: (Math.random() - 0.5) * 200,
                    z: 0,
                },
                data: {
                    label: 'Container',
                    content: '<div style="background: rgba(100,150,200,0.5); padding: 10px; border-radius: 5px;">Container</div>',
                    width: 120,
                    height: 80,
                },
            });

            containers.push(containerNode);
            nodes.push(containerNode);
            console.log(`Added container`);
        }

        function forceAdaptation() {
            const layouts = ['force', 'circular', 'grid', 'hierarchical'];
            const currentLayout = 'force'; // Default assumption
            const availableLayouts = layouts.filter(l => l !== currentLayout);
            const targetLayout = availableLayouts[Math.floor(Math.random() * availableLayouts.length)];

            console.log(`Forced adaptation to ${targetLayout}`);
            applySelectedLayout(targetLayout, 'standard');
        }

        function showLayoutConnections() {
            console.log('Showing layout connections');
            // In a real implementation, this would highlight connections
        }

        // Create the demo graph
        createDemoGraph();

        // Start the animation loop
        space.animate();
    }

    // Initialize when the page loads
    document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
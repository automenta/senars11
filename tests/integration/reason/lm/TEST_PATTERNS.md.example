/**
 * Ergonomic Test Patterns for LM-NAL Integration Tests
 * 
 * This file demonstrates clean, reusable patterns following AGENTS.md guidelines.
 * Use these helpers as templates for writing new integration tests.
 */

// ============================================================================
// UTILITY HELPERS - DRY and terse
// ============================================================================

const wait = ms => new Promise(r => setTimeout(r, ms));

const config = {
    lm: { provider: 'transformers', modelName: 'mock-model', enabled: true },
    subsystems: { lm: true }
};

const mockLM = responses => prompt => {
    for (const [pattern, response] of Object.entries(responses)) {
        if (prompt.includes(pattern)) return response;
    }
    return '';
};

const setupAgent = async (mockResponses) => {
    const app = new App(config);
    const agent = await app.start({ startAgent: true });
    await wait(1000);
    jest.spyOn(agent.lm, 'generateText').mockImplementation(mockLM(mockResponses));
    return { app, agent, termFactory: new TermFactory() };
};

// ============================================================================
// TERM EXTRACTION - Single source of truth
// ============================================================================

const getTerms = agent => [
    ...agent.getConcepts().map(c => c.term.toString()),
    ...agent.getBeliefs().map(b => b.term.toString()),
    ...agent.getQuestions().map(q => q.term.toString()),
    ...agent.getGoals().map(g => g.term.toString())
];

const hasTermMatch = (terms, ...patterns) =>
    terms.some(t => patterns.every(p => t.includes(p)));

const hasAnyMatch = (terms, words) =>
    terms.some(t => words.some(w => t.includes(w)));

// ============================================================================
// TASK BUILDERS - Fluent, readable patterns
// ============================================================================

const createTask = (termFactory, type, term, opts = {}) => new Task({
    term: termFactory.atomic(term),
    punctuation: type,
    budget: { priority: 0.9, ...opts.budget },
    truth: { frequency: 1.0, confidence: 0.9, ...opts.truth }
});

const belief = (termFactory, term, opts) =>
    createTask(termFactory, Punctuation.BELIEF, term, opts);

const goal = (termFactory, term, opts) =>
    createTask(termFactory, Punctuation.GOAL, term, opts);

const question = (termFactory, term, opts) =>
    createTask(termFactory, Punctuation.QUESTION, term, opts);

// ============================================================================
// TEST SUITE PATTERN - Clean, consistent structure
// ============================================================================

describe('My Test Suite', () => {
    let app, agent, termFactory;

    beforeAll(async () => ({
        app,
        agent,
        termFactory
    } = await setupAgent(mockResponses)));

    afterAll(async () => {
        if (app) await app.shutdown();
        jest.restoreAllMocks();
    });

    test('my test case', async () => {
        await agent.input(belief(termFactory, '"my belief"'));
        await wait(2000);

        const terms = getTerms(agent);
        expect(hasTermMatch(terms, 'expected', 'patterns')).toBe(true);
    });
});

// ============================================================================
// PATTERN VARIATIONS
// ============================================================================

// Pattern 1: Simple belief/question/goal test
test('simple test', async () => {
    await agent.input('"input".');
    await wait(2000);
    expect(hasAnyMatch(getTerms(agent), ['word1', 'word2'])).toBe(true);
});

// Pattern 2: Multi-step chain
test('chain test', async () => {
    await agent.input('<a --> b>.');
    await wait(1000);
    await agent.input('<b --> c>.');
    await wait(2000);
    expect(hasTermMatch(getTerms(agent), 'a', 'c')).toBe(true);
});

// Pattern 3: Task with custom budget/truth
test('task test', async () => {
    await agent.input(belief(termFactory, '"my belief"', {
        budget: { priority: 0.95 },
        truth: { frequency: 0.8, confidence: 0.9 }
    }));
    await wait(2000);
    expect(getTerms(agent).length).toBeGreaterThan(0);
});

// ============================================================================
// ANTI-PATTERNS TO AVOID
// ============================================================================

// ❌ Don't repeat new Promise(r => setTimeout(r, ms))
// ✅ Use: await wait(2000)

// ❌ Don't extract concepts/beliefs/goals separately
// ✅ Use: const terms = getTerms(agent)

// ❌ Don't use verbose conditionals
// ✅ Use: hasTermMatch(terms, 'word1', 'word2')

// ❌ Don't create redundant intermediate variables
// ✅ Inline when clear: expect(getTerms(agent).length).toBeGreaterThan(0)

// ❌ Don't use || when ?? is appropriate
// ✅ Use: data.field ?? defaultValue

// ❌ Don't write unnecessary comments explaining obvious code
// ✅ Self-documenting code with clear names
